---
layout: default
---

<main>
	<p>
		Imagerator is a project that does things with stuff and the stuff
		does the big complicated thing to make it happen.
	</p>
	<input id="input" type="file" accept="image/*"><br><br>
	<canvas id="canvas" style="width: 100%;"></canvas><br><br>
	<div style="display: inline-block;">
		<h5 style="display: inline;">Granularity</h5><br>
		<input id="granularity" type="range" min="2" max="100" value="10">
		<span id="granularityNumber">10</span>
	</div>
	<button id="start" style="float: right;">Start</button>
</main>

<script>
	const inputElement = document.getElementById("input");
	const canvasElement = document.getElementById("canvas");
	const granularityElement = document.getElementById("granularity");
	const granularityNumberElement = document.getElementById("granularityNumber");
	const startElement = document.getElementById("start");

	const canvasContext = canvasElement.getContext("2d");

	canvasContext.msImageSmoothingEnabled = false;
	canvasContext.mozImageSmoothingEnabled = false;
	canvasContext.webkitImageSmoothingEnabled = false;
	canvasContext.imageSmoothingEnabled = false;

	var _pixelRatio = 3;
	var granularity = 10;
	
	var origImageData = [];
	var granularImageData = [];
	var imageHeight = 0;
	var imageWidth = 0;
	var dataMap = {};

	granularityElement.addEventListener("input", function(e) {
		granularityNumberElement.innerHTML = granularityElement.value;
	});

	granularityElement.addEventListener("change", function(e) {
		granularity = granularityElement.value;
		onGranularityChange();
	});

	inputElement.addEventListener("change", function(e) {
		var img = new Image();
		img.onload = function() {
			canvasContext.canvas.height = img.height * (canvasContext.canvas.width / img.width);
			canvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvasContext.canvas.width, img.height * (canvasContext.canvas.width / img.width));

			let imageData = canvasContext.getImageData(0, 0, canvasContext.canvas.width, canvasContext.canvas.height);
			origImageData = [];
			for (let i = 0; i < imageData.data.length; i += imageData.width * 4 * _pixelRatio * _pixelRatio) {
				for (let i2 = i; i2 < i + (imageData.width * 4 * _pixelRatio); i2 += 4 * _pixelRatio) {
					origImageData.push(imageData.data[i2]);
					origImageData.push(imageData.data[i2+1]);
					origImageData.push(imageData.data[i2+2]);
					origImageData.push(255);
				}
			}
			
			imageHeight = imageData.height;
			imageWidth = imageData.width;
			
			onGranularityChange();
		};
		img.src = URL.createObjectURL(e.target.files[0]);
	});

	/**
	 * This function is called whenever the granularity of the image is updated.
	 * It should take the origImageData array (an array of 0-255 ints in multiples 
	 * of four; rgba values), sort them into the amount of "arrays" specified by
	 * `granularity`, store the average values of said arrays in `colors`, and
	 * write the "averaged" version of the image data to `granularImageData`,
	 * passing it to the `canvasContext` as it does so.
	 */
	async function onGranularityChange() {
		let totalColors = [];
		let colors = [];
		for (let i = 0; i < origImageData.length; i += 4) {
			totalColors.push({r: origImageData[i], g: origImageData[i+1], b: origImageData[i+2]});
		}

		// decide initial colors (start at 0, find the farthest away color, etc)		
		colors.push(Object.assign({}, totalColors[0])); // shallow copy; as the colors array stores average colors of the whole image,
														// its color data will be modified, which (if stored in totalColors) would affect
														// the original image data
		totalColors[0].taken = true;
		totalColors[0].owner = 0;
		console.log(totalColors[0]);

		console.log("starting initial heuristic");

		for (let i = 1; i < granularity && i < totalColors.length; i++) {
			let maxDistance = 0;
			let color = null;

			// get color with the farthest distance from all the current "colors"
			for (let i2 = 0; i2 < totalColors.length; i2++) {
				if (!totalColors[i2].taken) {
					let distance = 255 * 3;

					// pick the smallest distance from any current "color" to compare
					for (let i3 = 0; i3 < colors.length; i3++) {
						let dist = colorDistance(colors[i3], totalColors[i2]);
						if (dist < distance)
							distance = dist;
					}

					if (distance == 0)
						continue;

					if (distance > maxDistance) {
						maxDistance = distance;
						color = totalColors[i2];
					}
				}
			}

			if (color === null) {
				console.error("null color in initial heuristic");
				break;
			} else {
				colors.push(Object.assign({}, color)); // again, shallow copy
				color.taken = true;
				color.owner = colors.length - 1;
				console.log(color);
			}
		}

		console.log("categorizing colors");

		// categorize colors into groups
		// amount of iterations should be near Math.ceil((totalColors.length - colors.length) / colors.length);
		while (true) {
			let hasColor = false;
		
			for (let i2 = 0; i2 < colors.length; i2++) {
				let minDistance = null;
				let color = null;

				// find closest color to color[i2]
				for (let i3 = 0; i3 < totalColors.length; i3++) {
					if (!totalColors[i3].taken && totalColors[i3].owner != i2) {
						let distance = colorDistance(colors[i2], totalColors[i3]);
						// continue if the current owner of totalColors[i3] is closer
						if (totalColors[i3].owner) // && distance >= colorDistance(colors[totalColors[i3].owner], totalColors[i3]))
							continue;

						if (minDistance === null || distance < minDistance) {
							minDistance = distance;
							color = totalColors[i3];
						}
					}
				}

				if (color) {
					hasColor = true;

					if (color.owner)
						console.log(i2 + " fighting over a color " + minDistance + " away");
					
					let owner = color.owner;
					color.owner = i2;							
				}
			}

			if (!hasColor)
				break;
		}

		console.log("forming final image");

		for (let i = 0; i < colors.length; i++) {
			console.log(colors[i]);
		}

		// form (& set) granular image data for canvas
		let imageData = canvasContext.createImageData(imageWidth, imageHeight);
		granularImageData = imageData.data;

		let i3 = 0;

		for (let i = 0; i < totalColors.length; i++) {
			let color = null;
			if (totalColors[i] && totalColors[i].owner) {
				color = colors[totalColors[i].owner];
			} else {
				console.error("Color without an owner at index " + i + "!");
				color = totalColors[i];				
			}

			if (color === null)
				color = colors[0]; // weird fallback

			let width = Math.floor(imageWidth / _pixelRatio);
			let row = Math.floor(i / width);
			let col = i % width;

			let startIndex = (row * 4 * _pixelRatio * imageWidth) + (col * 4 * _pixelRatio);
			for (let i2 = startIndex; i2 < startIndex + (4 * _pixelRatio); i2 += 4) {
				for (i3 = i2; i3 < i2 + (4 * _pixelRatio * imageWidth); i3 += (4 * imageWidth)) {
					imageData.data[i3  ] = color.r;
					imageData.data[i3+1] = color.g;
					imageData.data[i3+2] = color.b;
					imageData.data[i3+3] = 255;
				}	
			}
		}
		canvasContext.putImageData(imageData, 0, 0);

		// TODO: generate 2d data set for use in actual iterations
	}
 
	/**
	 * Calculates the distance between two colors. This is currently the worst
	 * color distance algorithm possible, and only accounts for rgb values, not
	 * colors as visible to the human eye. This should be changed in the future.
	 * 
	 * @param c1		The first color object.
	 * @param c2		The second color object.
	 */
	function colorDistance(c1, c2) {
		if (!c1 || !c2) {
			console.error("You did a big dumb");
			return 99999999;
		}
		
		return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
	}
</script>
