---
layout: default
---

<main>
	<p>
		Imagerator is a project that does things with stuff and the stuff
		does the big complicated thing to make it happen.
	</p>
	<input id="input" type="file" accept="image/*"><br><br>
	<canvas id="canvas" style="width: 100%;"></canvas><br><br>
	<div style="display: inline-block;">
		<h5 style="display: inline;">Granularity</h5><br>
		<input id="granularity" type="range" min="2" max="500" value="10">
		<span id="granularityNumber">10</span>
	</div>
	<button style="float: right;">Start</button>
	<h3>Progress: <span id="progress">Not started...</span></h3>
</main>

<script>
	const inputElement = document.getElementById("input");
	const canvasElement = document.getElementById("canvas");
	const granularityElement = document.getElementById("granularity");
	const granularityNumberElement = document.getElementById("granularityNumber");
	const progressElement = document.getElementById("progress");

	const canvasContext = canvasElement.getContext("2d");

	canvasContext.msImageSmoothingEnabled = false;
	canvasContext.mozImageSmoothingEnabled = false;
	canvasContext.webkitImageSmoothingEnabled = false;
	canvasContext.imageSmoothingEnabled = false;

	var granularity = 10;
	
	var origImageData = [];
	var granularImageData = [];
	var imageHeight = 0;
	var imageWidth = 0;
	var dataMap = {};

	granularityElement.addEventListener("input", function(e) {
		granularityNumberElement.innerHTML = granularityElement.value;
	});

	granularityElement.addEventListener("change", function(e) {
		granularity = granularityElement.value;
		onGranularityChange();
	});

	inputElement.addEventListener("change", function(e) {
		var img = new Image();
		img.onload = function() {
			canvasContext.canvas.height = img.height * (canvasContext.canvas.width / img.width);
			canvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvasContext.canvas.width, img.height * (canvasContext.canvas.width / img.width));

			let imageData = canvasContext.getImageData(0, 0, canvasContext.canvas.width, canvasContext.canvas.height);
			origImageData = [];
			for (let i = 0; i < imageData.data.length; i += imageData.width * 40) {
				for (let i2 = i; i2 < i + (imageData.width * 40); i2 += 40) {
					origImageData.push(imageData.data[i2]);
					origImageData.push(imageData.data[i2+1]);
					origImageData.push(imageData.data[i2+2]);
					origImageData.push(255);
				}
			}
			
			imageHeight = imageData.height;
			imageWidth = imageData.width;
			
			onGranularityChange();
		};
		img.src = URL.createObjectURL(e.target.files[0]);
	});

	/**
	 * This function is called whenever the granularity of the image is updated.
	 * It should take the origImageData array (an array of 0-255 ints in multiples 
	 * of four; rgba values), sort them into the amount of "arrays" specified by
	 * `granularity`, store the average values of said arrays in `colors`, and
	 * write the "averaged" version of the image data to `granularImageData`,
	 * passing it to the `canvasContext` as it does so.
	 */
	async function onGranularityChange() {
		let totalColors = [];
		let colors = [];
		for (let i = 0; i < origImageData.length; i += 4) {
			totalColors.push({r: origImageData[i], g: origImageData[i+1], b: origImageData[i+2]});
		}

		// decide initial colors (start at 0, find the farthest away color, etc)		
		colors.push(Object.assign({}, totalColors[0])); // shallow copy; as the colors array stores average colors of the whole image,
														// its color data will be modified, which (if stored in totalColors) would affect
														// the original image data
		totalColors[0].taken = true;
		totalColors[0].owner = 0;

		let progressTotal = granularity;
		let progress = 1;

		console.log("starting initial heuristic");

		for (let i = 1; i < granularity && i < totalColors.length; i++) {
			let maxDistance = 0;
			let color = null;
			
			for (let i2 = 0; i2 < totalColors.length; i2++) {
				let distance = 0;
				
				if (!totalColors[i2])
					continue;
				
				if (!totalColors[i2].taken) {
					for (let i3 = 0; i3 < colors.length; i3++) {
						distance += colorDistance(colors[i3], totalColors[i2]);
					}

					distance /= colors.length;

					if (distance > maxDistance) {
						maxDistance = distance;
						color = totalColors[i2];
					}
				}
			}

			if (color === null) {
				break;
			} else {
				colors.push(Object.assign({}, color)); // again, shallow copy
				color.taken = true;
				color.owner = colors.length - 1;
			}

			progress++;
			updateProgress(progress, progressTotal);
		}

		console.log("categorizing colors");

		let iterations = Math.ceil((totalColors.length - colors.length) / colors.length);
		progressTotal += iterations;

		// categorize colors into groups
		while (true) {
			let hasColor = false;
		
			for (let i2 = 0; i2 < colors.length; i2++) {
				let minDistance = null;
				let color = null;

				// find closest color to color[i2]
				for (let i3 = 0; i3 < totalColors.length; i3++) {
					if (!totalColors[i3].taken && totalColors[i3].owner != i2) {
						let distance = colorDistance(colors[i2], totalColors[i3]);
						// continue if the current owner of totalColors[i3] is closer
						if (totalColors[i3].owner) // && distance >= colorDistance(colors[totalColors[i3].owner], totalColors[i3]))
							continue;

						if (minDistance === null || distance < minDistance) {
							minDistance = distance;
							color = totalColors[i3];
						}
					}
				}

				if (color) {
					hasColor = true;

					if (color.owner)
						console.log(i2 + " fighting over a color " + minDistance + " away");
					
					let owner = color.owner;
					color.owner = i2;

					// recalculate average for original owner
					if (owner) {
						colors[owner].r = null;
						colors[owner].b = null;
						colors[owner].g = null;
						let count = 0;
						
						for (let i3 = 0; i3 < totalColors.length; i3++) {
							if (totalColors[i3].owner == owner) {
								if (colors[owner].r)
									colors[owner].r = ((colors[owner].r * count) + totalColors[i3].r) / (count + 1);
								else colors[owner].r = totalColors[i3].r;

								if (colors[owner].g)
									colors[owner].g = ((colors[owner].g * count) + totalColors[i3].g) / (count + 1);
								else colors[owner].g = totalColors[i3].g;

								if (colors[owner].b)
									colors[owner].b = ((colors[owner].b * count) + totalColors[i3].b) / (count + 1);
								else colors[owner].b = totalColors[i3].b;
								
								count++;
							}
						}
					}

					// recalculate average for colors[i2]
					colors[i2].r = null;
					colors[i2].g = null;
					colors[i2].b = null;					
					let count = 0;
					
					for (let i3 = 0; i3 < totalColors.length; i3++) {
						if (totalColors[i3].owner == i2) {
							if (colors[i2].r)
								colors[i2].r = ((colors[i2].r * count) + totalColors[i3].r) / (count + 1);
							else colors[i2].r = totalColors[i3].r;

							if (colors[i2].g)
								colors[i2].g = ((colors[i2].g * count) + totalColors[i3].g) / (count + 1);
							else colors[i2].g = totalColors[i3].g;

							if (colors[i2].b)
								colors[i2].b = ((colors[i2].b * count) + totalColors[i3].b) / (count + 1);
							else colors[i2].b = totalColors[i3].b;
								
							count++;
						}
					}							
				}
			}

			progress++;
			updateProgress(progress, progressTotal);
			await sleep(10);

			if (!hasColor)
				break;
		}

		console.log("forming final image");
		progressTotal += totalColors.length;

		// form (& set) granular image data for canvas
		let imageData = canvasContext.createImageData(imageWidth, imageHeight);
		granularImageData = imageData.data;

		for (let i = 0; i < totalColors.length; i++) {
			let color = null;
			if (totalColors[i] && totalColors[i].owner) {
				color = colors[totalColors[i].owner];
			} else {
				console.error("Color without an owner at index " + i + "!");
				color = totalColors[i];				
			}

			if (!color)
				color = { r: 0, g: 0, b: 0 };


			for (let i2 = i * 40; i2 < (i * 40) + 40; i2 += 4) {
					imageData.data[i2  ] = color.r;
					imageData.data[i2+1] = color.g;
					imageData.data[i2+2] = color.b;
					imageData.data[i2+3] = 255;
			}

			progress++;
			updateProgress(progress, progressTotal);
			await sleep(10);
		}
		canvasContext.putImageData(imageData, 0, 0);

		progress = progressTotal;
		updateProgress(progress, progressTotal);

		// TODO: generate 2d data set for use in actual iterations
	}
 
	/**
	 * Calculates the distance between two colors. This is currently the worst
	 * color distance algorithm possible, and only accounts for rgb values, not
	 * colors as visible to the human eye. This should be changed in the future.
	 * 
	 * @param c1		The first color object.
	 * @param c2		The second color object.
	 */
	function colorDistance(c1, c2) {
		if (!c1 || !c2) {
			console.error("You did a big dumb");
			return 99999999;
		}
		
		return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
	}

	function updateProgress(progress, total) {
		progressElement.innerHTML = Math.round(progress * 100 / total) + "%";
	}

	function sleep(duration) {
		return new Promise(function(resolve) {
			setTimeout(resolve, duration);
		});
	}
</script>
