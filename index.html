---
layout: default
---

<main>
	<p>
		Imagerator is a project that does things with stuff and the stuff
		does the big complicated thing to make it happen.
	</p>
	<input id="input" type="file" accept="image/*"><br><br>
	<canvas id="canvas" style="width: 100%;"></canvas><br><br>
	<div style="display: inline-block;">
		<h5 style="display: inline;">Granularity</h5><br>
		<input id="granularity" type="range" min="2" max="500" value="50">
		<span id="granularityNumber">50</span>
	</div>
	<button style="float: right;">Start</button>
</main>

<script>
	const inputElement = document.getElementById("input");
	const canvasElement = document.getElementById("canvas");
	const granularityElement = document.getElementById("granularity");
	const granularityNumberElement = document.getElementById("granularityNumber");

	const canvasContext = canvasElement.getContext("2d");

	var granularity = 100;
	
	var origImageData = [];
	var granularImageData = [];
	var colors = [];
	var dataMap = {};

	granularityElement.addEventListener("input", function(e) {
		granularityNumberElement.innerHTML = granularityElement.value;
	});

	granularityElement.addEventListener("change", function(e) {
		granularity = granularityElement.value;
		onGranularityChange();
	});

	inputElement.addEventListener("change", function(e) {
		var img = new Image();
		img.onload = function() {
			canvasContext.canvas.height = img.height * (canvasContext.canvas.width / img.width);
			canvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvasContext.canvas.width, img.height * (canvasContext.canvas.width / img.width));

			origImageData = canvasContext.getImageData(0, 0, canvasContext.canvas.width, canvasContext.canvas.height);
			onGranularityChange();
		};
		img.src = URL.createObjectURL(e.target.files[0]);
	});

	/**
	 * This function is called whenever the granularity of the image is updated.
	 * It should take the origImageData array (an array of 0-255 ints in multiples 
	 * of four; rgba values), sort them into the amount of "arrays" specified by
	 * `granularity`, store the average values of said arrays in `colors`, and
	 * write the "averaged" version of the image data to `granularImageData`,
	 * passing it to the `canvasContext` as it does so.
	 */
	function onGranularityChange() {
		colors = [];
		for (let i = 0; i < origImageData.length; i += 4) {
			colors.push({r: origImageData[i], g: origImageData[i+1], b: origImageData[i+2]});
		}
	}
 
	/**
	 * Calculates the distance between two colors. This is currently the worst
	 * color distance algorithm possible, and only accounts for rgb values, not
	 * colors as visible to the human eye. This should be changed in the future.
	 * 
	 * @param c1		The first color object.
	 * @param c2		The second color object.
	 */
	function colorDistance(c1, c2) {
		return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
	}
</script>
