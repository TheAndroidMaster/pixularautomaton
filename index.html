---
layout: default
---

<main>
	<p>
		Imagerator is a project that does things with stuff and the stuff
		does the big complicated thing to make it happen.
	</p>
	<input id="input" type="file" accept="image/*"><br><br>
	<div style="display: inline-block;">
		<h5 style="display: inline;">Granularity</h5><br>
		<input id="granularity" type="range" min="2" max="100" value="10">
		<span id="granularityNumber">10</span>
	</div>&nbsp;&nbsp;
	<div style="display: inline-block;">
		<h5 style="display: inline;">Pixelation</h5><br>
		<input id="pixels" type="range" min="2" max="10" value="4">
		<span id="pixelsNumber">4</span>
	</div>
	<button id="start" style="float: right;">Start</button><br><br>
	<canvas id="canvas" style="width: 100%;"></canvas>
</main>

<script>
	const _inputElement = document.getElementById("input");
	const _canvasElement = document.getElementById("canvas");
	const _granularityElement = document.getElementById("granularity");
	const _granularityNumberElement = document.getElementById("granularityNumber");
	const _pixelsElement = document.getElementById("pixels");
	const _pixelsNumberElement = document.getElementById("pixelsNumber");
	const _startElement = document.getElementById("start");

	const _canvasContext = _canvasElement.getContext("2d");

	_canvasContext.msImageSmoothingEnabled = false;
	_canvasContext.mozImageSmoothingEnabled = false;
	_canvasContext.webkitImageSmoothingEnabled = false;
	_canvasContext.imageSmoothingEnabled = false;

	var _pixelRatio = 4;
	var _granularity = 10;

	var _inputImageData;

	var _colors = [];
	var _origImageData = [];
	var _granularImageData = [];
	var _imageHeight = 0;
	var _imageWidth = 0;
	var _imageGrid = [];	

	_granularityElement.addEventListener("input", function(e) {
		_granularityNumberElement.innerHTML = _granularityElement.value;
	});

	_granularityElement.addEventListener("change", function(e) {
		_granularity = _granularityElement.value;
		onGranularityChange();
	});

	_pixelsElement.addEventListener("input", function(e) {
		_pixelsNumberElement.innerHTML = _pixelsElement.value;
	});

	_pixelsElement.addEventListener("change", function(e) {
		_pixelRatio = _pixelsElement.value;
		if (_inputImageData)
			scaleInputImage(_inputImageData);
	});

	_inputElement.addEventListener("change", function(e) {
		var img = new Image();
		img.onload = function() {
			_canvasContext.canvas.height = img.height * (_canvasContext.canvas.width / img.width);
			_canvasContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, _canvasContext.canvas.width, img.height * (_canvasContext.canvas.width / img.width));

			_inputImageData = _canvasContext.getImageData(0, 0, _canvasContext.canvas.width, _canvasContext.canvas.height);
			scaleInputImage(_inputImageData);
		};
		img.src = URL.createObjectURL(e.target.files[0]);
	});

	function scaleInputImage(imageData) {
		_origImageData = [];
		for (let i = 0; i < imageData.data.length; i += imageData.width * 4 * _pixelRatio * _pixelRatio) {
			for (let i2 = i; i2 < i + (imageData.width * 4 * _pixelRatio); i2 += 4 * _pixelRatio) {
				_origImageData.push(imageData.data[i2]);
				_origImageData.push(imageData.data[i2+1]);
				_origImageData.push(imageData.data[i2+2]);
				_origImageData.push(255);
			}
		}
			
		_imageHeight = imageData.height;
		_imageWidth = imageData.width;

		onGranularityChange();
	}

	/**
	 * This function is called whenever the granularity of the image is updated.
	 * It should take the origImageData array (an array of 0-255 ints in multiples 
	 * of four; rgba values), sort them into the amount of "arrays" specified by
	 * `_granularity`, store the average values of said arrays in `colors`, and
	 * write the "averaged" version of the image data to `_granularImageData`,
	 * passing it to the `_canvasContext` as it does so.
	 */
	async function onGranularityChange() {
		let totalColors = [];
		_colors = [];
		for (let i = 0; i < _origImageData.length; i += 4) {
			totalColors.push({r: _origImageData[i], g: _origImageData[i+1], b: _origImageData[i+2]});
		}

		// decide initial colors (start at 0, find the farthest away color, etc)		
		_colors.push(Object.assign({}, totalColors[0])); // shallow copy; as the colors array stores average colors of the whole image,
														// its color data will be modified, which (if stored in totalColors) would affect
														// the original image data
		totalColors[0].taken = true;
		totalColors[0].owner = 0;
		console.log(totalColors[0]);

		console.log("starting initial heuristic");

		for (let i = 1; i < _granularity && i < totalColors.length; i++) {
			let maxDistance = 0;
			let color = null;

			// get color with the farthest distance from all the current "colors"
			for (let i2 = 0; i2 < totalColors.length; i2++) {
				if (!totalColors[i2].taken) {
					let distance = 255 * 3;

					// pick the smallest distance from any current "color" to compare
					for (let i3 = 0; i3 < _colors.length; i3++) {
						let dist = colorDistance(_colors[i3], totalColors[i2]);
						if (dist < distance)
							distance = dist;
					}

					if (distance == 0)
						continue;

					if (distance > maxDistance) {
						maxDistance = distance;
						color = totalColors[i2];
					}
				}
			}

			if (color === null) {
				console.error("null color in initial heuristic");
				break;
			} else {
				_colors.push(Object.assign({}, color)); // again, shallow copy
				color.taken = true;
				color.owner = _colors.length - 1;
				console.log(color);
			}
		}

		console.log("categorizing colors");

		// categorize colors into groups
		// amount of iterations should be near Math.ceil((totalColors.length - _colors.length) / _colors.length);
		while (true) {
			let hasColor = false;
		
			for (let i2 = 0; i2 < _colors.length; i2++) {
				let minDistance = null;
				let color = null;

				// find closest color to color[i2]
				for (let i3 = 0; i3 < totalColors.length; i3++) {
					if (!totalColors[i3].taken && totalColors[i3].owner != i2) {
						let distance = colorDistance(_colors[i2], totalColors[i3]);
						// continue if the current owner of totalColors[i3] is closer
						if (totalColors[i3].owner) // && distance >= colorDistance(_colors[totalColors[i3].owner], totalColors[i3]))
							continue;

						if (minDistance === null || distance < minDistance) {
							minDistance = distance;
							color = totalColors[i3];
						}
					}
				}

				if (color) {
					hasColor = true;

					if (color.owner)
						console.log(i2 + " fighting over a color " + minDistance + " away");
					
					let owner = color.owner;
					color.owner = i2;							
				}
			}

			if (!hasColor)
				break;
		}

		console.log("forming final image");

		// form a grid of granular image data for canvas
		_imageGrid = [];
		let width = Math.floor(_imageWidth / _pixelRatio);
		
		for (let i = 0; i < totalColors.length; i++) {
			let owner = 0;
			if (totalColors[i] && totalColors[i].owner) {
				owner = totalColors[i].owner;
			} else {
				console.error("Color without an owner at index " + i + "!");
				owner = 0;
			}

			let row = Math.floor(i / width);
			let col = i % width;

			if (!_imageGrid[row])
				_imageGrid[row] = [];

			_imageGrid[row][col] = owner;
		}

		updateCanvasImage();
	}

	/**
	 * Updates the image drawn on the canvas to match the grid of colors
	 * defined in `_imageGrid`.
	 */
	function updateCanvasImage() {
		console.log("updating canvas");
	
		let imageData = _canvasContext.createImageData(_imageWidth, _imageHeight);
		_granularImageData = imageData.data;

		let width = Math.floor(_imageWidth / _pixelRatio);
		for (let row = 0; row < _imageGrid.length; row++) {
			for (let col = 0; col < _imageGrid[row].length; col++) {
				let color = _colors[_imageGrid[row][col]];

				let startIndex = (row * 4 * _pixelRatio * _imageWidth) + (col * 4 * _pixelRatio);
				for (let i2 = startIndex; i2 < startIndex + (4 * _pixelRatio); i2 += 4) {
					for (let i3 = i2; i3 < i2 + (4 * _pixelRatio * _imageWidth); i3 += (4 * _imageWidth)) {
						imageData.data[i3  ] = color.r;
						imageData.data[i3+1] = color.g;
						imageData.data[i3+2] = color.b;
						imageData.data[i3+3] = 255;
					}	
				}
			}
		}
		
		_canvasContext.putImageData(imageData, 0, 0);
	}
 
	/**
	 * Calculates the distance between two colors. This is currently the worst
	 * color distance algorithm possible, and only accounts for rgb values, not
	 * colors as visible to the human eye. This should be changed in the future.
	 * 
	 * @param c1		The first color object.
	 * @param c2		The second color object.
	 */
	function colorDistance(c1, c2) {
		if (!c1 || !c2) {
			console.error("You did a big dumb");
			return 99999999;
		}
		
		return Math.abs(c1.r - c2.r) + Math.abs(c1.g - c2.g) + Math.abs(c1.b - c2.b);
	}
</script>
